use std::io;

pub fn data_types() {
    // It is common to indent with 4 spaces
    // You can tell println is a macro because of the !
    // and not a function
    println!("What is your name?");

    // Define an mutable variable (Value can changed)
    // String::new : A function that returns an empty string
    let mut name = String::new();

    /*
    By default variables are immutable (Value can't Change)
    but it is possible to use mutable variables
    It is beneficial to use immutable variables because then
    you don't have to track down how values change
    */

    // This string is immutable
    // Define it is a string with double quotes
    let greeting = "Nice to meet you";

    /*
    Receive input from the user with read_line
    name is passed as an argument to read_line
    & defines that this variable is a reference to the variable
    which allows read_line to save values directly to name
    You use mut to define that name is a mutable variable
    */

    /*
    read_line returns io::Result which is an enum
    Enums have a fixed number of specific values (Ok or Err)
    If Err is returned the operation failed and Err can tell you why
    Result has an expect function that returns any error that occurred
    (We should handle this error, but we'll cover that later)
    */
    io::stdin()
        .read_line(&mut name)
        .expect("Didn't Receive Input");

    // Were you have {} your variable values will be placed
    // To remove the newline after name use trim_end
    println!("Hello {}! {}", name.trim_end(), greeting);

    // ----- VARIABLES -----

    // Constants can be declared in any scope and used globally
    // They differ from immutable variables in that their value
    // can't be defined at runtime (based on a function call for example)
    const ONE_MIL: u32 = 1_000_000;
    const PI: f32 = 3.141592;

    // You can define variables with the same name but with different
    // data types (Shadowing)
    let age = "47";

    // Trim eliminates white space and parse converts the string into an int
    // We expect age to have an integer value and expect will throw an
    // error if this isn't true (We'll get more into error handling later)
    let mut age: u32 = age.trim().parse().expect("Age wasn't assigned a number");
    age = age + 1;

    println!("I'm {} and I want ${}", age, ONE_MIL);

    // ----- DATA TYPES -----
    // Rust is statically typed which means all types must be defined
    // These types are autogenerated by the compiler or defined explicitly

    // Unsigned integer : u8, u16, u32, u64, u128, usize
    // Signed integer : i8, i16, i32, i64, i128, isize
    let max_u32 = u32::MAX;
    println!("Max u32 : {}", max_u32);
    println!("Max u64 : {}", u64::MAX);
    // usize depends on your computer (If 64 bit then it's 64 bit)
    println!("Max usize : {}", usize::MAX);
    println!("Max u128 : {}", u128::MAX);

    // Floating Points : f32, f64
    println!("Max f32 : {}", f32::MAX);
    println!("Max f64 : {}", f64::MAX);

    // Booleans can have either the value true or false
    let _is_true = true;

    // Characters are defined with single quotes
    // They can store most any type of character from any language
    let _my_grade = 'A';

    // ----- CASTING WITH AS -----
    // You can convert to different types in multiple ways
    let int_u8: u8 = 5;
    let int2_u8: u8 = 4;
    // Cast using as
    let _int3_u32: u32 = (int_u8 as u32) + (int2_u8 as u32);
}
